

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gpp_linear_algebra &mdash; MOE 0.1.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/breathe.css" type="text/css" />
  
    <link rel="top" title="MOE 0.1.0 documentation" href="index.html"/>
        <link rel="up" title="C++ Files" href="cpp_tree.html"/>
        <link rel="next" title="gpp_heuristic_expected_improvement_optimization_test" href="gpp_heuristic_expected_improvement_optimization_test.html"/>
        <link rel="prev" title="gpp_geometry_test" href="gpp_geometry_test.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> MOE</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="why_moe.html">Why Do We Need MOE?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="why_moe.html#what-is-moe">What is MOE?</a></li>
<li class="toctree-l2"><a class="reference internal" href="why_moe.html#why-is-this-hard">Why is this hard?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install</a><ul>
<li class="toctree-l2"><a class="reference internal" href="install.html#install-in-docker">Install in docker:</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#install-from-source">Install from source:</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#osx-tips-10-8-for-10-9-see-separate-instructions-below">OSX Tips (&lt;=10.8. For 10.9, see separate instructions below):</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#linux-tips">Linux Tips:</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#cmake-tips">CMake Tips:</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="objective_functions.html">Objective Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="objective_functions.html#what-is-an-objective-function">What is an objective function?</a></li>
<li class="toctree-l2"><a class="reference internal" href="objective_functions.html#properties-of-an-objective-function">Properties of an objective function</a></li>
<li class="toctree-l2"><a class="reference internal" href="objective_functions.html#parameters">Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="objective_functions.html#id1"><span class="math">\(\Phi\)</span> Objective Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="objective_functions.html#example-of-objective-functions">Example of Objective Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples.html#minimizing-an-arbitrary-function">Minimizing an arbitrary function</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#gaussian-process-regression-given-historical-data">Gaussian Process regression given historical data</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#hyperparameter-optimization-of-a-gaussian-process">Hyperparameter optimization of a Gaussian Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#all-above-examples-combined">All above examples combined</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#setting-thresholds-for-advertising-units">Setting thresholds for advertising units</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#making-a-pull-request">Making a pull request</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#testing">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html#style">Style</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="moe.html">moe package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="moe.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="moe.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="moe.html#module-moe.resources">moe.resources module</a></li>
<li class="toctree-l2"><a class="reference internal" href="moe.html#module-moe">Module contents</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="cpp_tree.html">C++ Files</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gpp_optimization_test.html">gpp_optimization_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_domain_test.html">gpp_domain_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_exception.html">gpp_exception</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_geometry.html">gpp_geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_heuristic_expected_improvement_optimization.html">gpp_heuristic_expected_improvement_optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_linear_algebra-inl.html">gpp_linear_algebra-inl</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_test_utils.html">gpp_test_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_logging.html">gpp_logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_covariance.html">gpp_covariance</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_python_test.html">gpp_python_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_domain.html">gpp_domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_python_common.html">gpp_python_common</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_hyperparameter_optimization_demo.html">gpp_hyperparameter_optimization_demo</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_test_utils_test.html">gpp_test_utils_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_math_test.html">gpp_math_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_python_expected_improvement.html">gpp_python_expected_improvement</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_python_model_selection.html">gpp_python_model_selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_math.html">gpp_math</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_random_test.html">gpp_random_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_expected_improvement_demo.html">gpp_expected_improvement_demo</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_random.html">gpp_random</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_geometry_test.html">gpp_geometry_test</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">gpp_linear_algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_heuristic_expected_improvement_optimization_test.html">gpp_heuristic_expected_improvement_optimization_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_linear_algebra_test.html">gpp_linear_algebra_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_core.html">gpp_core</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_optimization.html">gpp_optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_covariance_test.html">gpp_covariance_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_python_gaussian_process.html">gpp_python_gaussian_process</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_mock_optimization_objective_functions.html">gpp_mock_optimization_objective_functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_python.html">gpp_python</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_model_selection_and_hyperparameter_optimization.html">gpp_model_selection_and_hyperparameter_optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_hyper_and_EI_demo.html">gpp_hyper_and_EI_demo</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_optimization_parameters.html">gpp_optimization_parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_common.html">gpp_common</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpp_model_selection_and_hyperparameter_optimization_test.html">gpp_model_selection_and_hyperparameter_optimization_test</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">MOE</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="cpp_tree.html">C++ Files</a> &raquo;</li>
      
    <li>gpp_linear_algebra</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/gpp_linear_algebra.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="gpp-linear-algebra">
<h1>gpp_linear_algebra<a class="headerlink" href="#gpp-linear-algebra" title="Permalink to this headline">¶</a></h1>
<p><strong>Contents:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li><a class="reference internal" href="#gpp-linear-algebra-hpp">gpp_linear_algebra.hpp</a></li>
<li><a class="reference internal" href="#gpp-linear-algebra-cpp">gpp_linear_algebra.cpp</a></li>
</ol>
</div></blockquote>
<div class="section" id="gpp-linear-algebra-hpp">
<h2>gpp_linear_algebra.hpp<a class="headerlink" href="#gpp-linear-algebra-hpp" title="Permalink to this headline">¶</a></h2>
<p></p>
<p><p>This file provides low level linear algebra functionality in support of the other gpp_* components.  The functions here
generally wrap BLAS (levels 1 through 3) and LAPACK functionality as well as a few utilities for convenience/debugging
(e.g., matrix print outs).</p>
<p>First, look over gpp_common.hpp for general comments on loop layouts, storage formats, and shorthand as well
as definitions of standard notation.</p>
<p>The functions here wrap BLAS/LAPACK functionality to make it convenient/easy to switch between different library
implementations (e.g., different vendors or even on a GPU).  They also provide an opportunity to avoid associated
overhead for &#8220;small&#8221; problem sizes.  These functions wrap BLAS:</p>
<ul class="simple">
<li>Level 1: <tt class="docutils literal"><span class="pre">O(n)</span></tt> operations; vector scale, dot product, etc.</li>
<li>Level 2: <tt class="docutils literal"><span class="pre">O(n^2)</span></tt> operations; Matrix-vector multiplies (+ special cases) and triangular solves</li>
<li>Level 3: <tt class="docutils literal"><span class="pre">O(n^3)</span></tt> operations: matrix-matrix multiplies and triangular solves</li>
</ul>
<p>and LAPACK:</p>
<ul class="simple">
<li>O(n^3), triangular factorization routines (PLU, Cholesky)</li>
<li>O(n^3), matrix inverse</li>
</ul>
<p>Matrix storage formats are always column-major as prescribed in gpp_common.hpp.
We also only deal with <em>lower</em> triangular matrices here; these are stored in the lower triangle.  The contents
of the upper triangle are ignored and can technically have any value, even NaN.
See PLU for further description of its special output format.</p>
 </p>
<p><p id="project0namespaceoptimal__learning"><em>namespace</em> <strong>optimal_learning</strong></p>
<blockquote>
<div><p></p>
<p></p>
<em>Functions</em><blockquote>
<div><p><span class="target" id="project0namespaceoptimal__learning_1ae8d1de59dc6885a287f40efde793da0a"></span><div class="line-block">
<div class="line"><a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1a43aad231fa6009d48201a76fd7dfb6dc"><em>OL_NONNULL_POINTERS</em></a>  void <strong>VectorScale</strong>(int size, double alpha, double *restrict vector)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Multiplies first <tt class="docutils literal"><span class="pre">size</span></tt> elements of <tt class="docutils literal"><span class="pre">vector</span></tt> by <tt class="docutils literal"><span class="pre">alpha</span></tt>, <tt class="docutils literal"><span class="pre">vector</span> <span class="pre">:=</span> <span class="pre">vector*alpha</span></tt>.</p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dscal(size,</span> <span class="pre">alpha,</span> <span class="pre">vector,</span> <span class="pre">1);</span></tt></p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">size:</th><td class="field-body">number of elements in vector</td>
</tr>
<tr class="field-even field"><th class="field-name">alpha:</th><td class="field-body">number to scale by</td>
</tr>
<tr class="field-odd field"><th class="field-name">vector[size]:</th><td class="field-body">vector to scale</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">vector[size]:</th><td class="field-body">vector with elements scaled</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a7db308d8b39598da574c427ef203d324"></span><div class="line-block">
<div class="line"><a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1a43aad231fa6009d48201a76fd7dfb6dc"><em>OL_NONNULL_POINTERS</em></a>  void <strong>VectorAXPY</strong>(int size, double alpha, double const *restrict vec1, double *restrict vec2)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Computes <tt class="docutils literal"><span class="pre">y_i</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">x_i</span> <span class="pre">+</span> <span class="pre">y_i</span></tt>; <tt class="docutils literal"><span class="pre">y</span></tt> is modified in-place.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">size:</th><td class="field-body">number of elements in <tt class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">alpha:</th><td class="field-body">quantity to scale by</td>
</tr>
<tr class="field-odd field"><th class="field-name">vec1[size]:</th><td class="field-body"><tt class="docutils literal"><span class="pre">x</span></tt>, vector to scale and add to <tt class="docutils literal"><span class="pre">y</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">vec2[size]:</th><td class="field-body"><tt class="docutils literal"><span class="pre">y</span></tt>, vector to add to</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">vec2[size]:</th><td class="field-body">input <tt class="docutils literal"><span class="pre">y</span></tt> plus <tt class="docutils literal"><span class="pre">alpha*x</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ae40737aa5d7d0df5673510ebbc789c29"></span><div class="line-block">
<div class="line"><a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1ab292cebcecf848d47dd4d631e3028390"><em>OL_PURE_FUNCTION</em></a>   <a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1a43aad231fa6009d48201a76fd7dfb6dc"><em>OL_NONNULL_POINTERS</em></a>   <a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1abda439d29ae03a473c1167e47159ae90"><em>OL_WARN_UNUSED_RESULT</em></a>  double <strong>DotProduct</strong>(double const *restrict vector1, double const *restrict vector2, int size)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Computes dot product between two vectors.</p>
<p>Equivalent BLAS call:
<tt class="docutils literal"><span class="pre">ddot(size,</span> <span class="pre">vector1,</span> <span class="pre">1,</span> <span class="pre">vector2,</span> <span class="pre">1);</span></tt></p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">vector1[size]:</th><td class="field-body">first vector</td>
</tr>
<tr class="field-even field"><th class="field-name">vector2[size]:</th><td class="field-body">second vector</td>
</tr>
<tr class="field-odd field"><th class="field-name">size:</th><td class="field-body">length of vectors</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Returns</strong>:</dt>
<dd>dot/inner product, <tt class="docutils literal"><span class="pre">&lt;vector1,</span> <span class="pre">vector2&gt;</span></tt></dd>
</dl>
 </p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ad85d21e26c2170391ea34d6a97c5486d"></span><div class="line-block">
<div class="line"><a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1a43aad231fa6009d48201a76fd7dfb6dc"><em>OL_NONNULL_POINTERS</em></a>  void <strong>CholeskyFactorLMatrixVectorSolve</strong>(double const *restrict A, int size_m, double *restrict x)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Solves <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt> IN-PLACE, where <tt class="docutils literal"><span class="pre">A</span></tt> has been previously cholesky-factored (<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">L^T</span></tt>) such that
the lower triangle of <tt class="docutils literal"><span class="pre">A</span></tt> contains <tt class="docutils literal"><span class="pre">L</span></tt>.
Consists of two calls to TriangularMatrixVectorSolve. As in that function, before calling, <tt class="docutils literal"><span class="pre">x</span></tt> holds the
RHS, <tt class="docutils literal"><span class="pre">b</span></tt>.  After return, <tt class="docutils literal"><span class="pre">x</span></tt> will be OVERWRITTEN with the solution.
No inputs may be nullptr.</p>
<p>Math:
<tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt>
<tt class="docutils literal"><span class="pre">L</span> <span class="pre">*</span> <span class="pre">L</span> <span class="pre">^T</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt>
<tt class="docutils literal"><span class="pre">L^T</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">L</span> <span class="pre">\</span> <span class="pre">b</span>&nbsp; <span class="pre">(dtrsv,</span> <span class="pre">no</span> <span class="pre">transpose)</span></tt>
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">L^T</span> <span class="pre">\</span> <span class="pre">(L</span> <span class="pre">\</span> <span class="pre">b)</span>&nbsp; <span class="pre">(dtrsv,</span> <span class="pre">transpose)</span></tt></p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dpotrs('L',</span> <span class="pre">size_m,</span> <span class="pre">1,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">x,</span> <span class="pre">size_m,</span> <span class="pre">&amp;info);</span></tt></p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">cholesky-factored system of equations such that its lower triangle
contains <tt class="docutils literal"><span class="pre">L</span></tt>.  i.e., result &#8216;chol&#8217; from ComputeCholeskyFactorL(A_full, size_m, chol)</td>
</tr>
<tr class="field-even field"><th class="field-name">size_m:</th><td class="field-body">dimension of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">x[size_m]:</th><td class="field-body">the RHS vector, <tt class="docutils literal"><span class="pre">b</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">x[size_m]:</th><td class="field-body">the solution, <tt class="docutils literal"><span class="pre">A\b</span></tt>.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1aa3feedd385e68787424d5d76e50f2639"></span><div class="line-block">
<div class="line"><a class="reference internal" href="gpp_common.html#project0gpp__common_8hpp_1a43aad231fa6009d48201a76fd7dfb6dc"><em>OL_NONNULL_POINTERS</em></a>  void <strong>CholeskyFactorLMatrixMatrixSolve</strong>(double const *restrict A, int size_m, int size_n, double *restrict X)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Same as CholeskyFactorLMatrixVectorSolve except this accepts matrix RHSs; it solves multi-RHS linear systems of the form:
<tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></tt>.
<tt class="docutils literal"><span class="pre">A</span></tt> must have been Cholesky-factored (<tt class="docutils literal"><span class="pre">L</span> <span class="pre">*</span> <span class="pre">L^T</span> <span class="pre">=</span> <span class="pre">A</span></tt>) beforehand, and it must hold the factor <tt class="docutils literal"><span class="pre">L</span></tt> in its lower trinagle.
Usually this is obtained via ComputeCholeskyFactorL().</p>
<p>Note that this operation is done IN-PLACE.  <tt class="docutils literal"><span class="pre">X</span></tt> initially holds <tt class="docutils literal"><span class="pre">B</span></tt> and is overwritten with the solution.</p>
<p>MATH:
This is analogous to CholeskyFactorLMatrixVectorSolve; see that function for further details.</p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dpotrs('L',</span> <span class="pre">size_m,</span> <span class="pre">size_n,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">X,</span> <span class="pre">size_m,</span> <span class="pre">&amp;info);</span></tt></p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">non-singular matrix holding <tt class="docutils literal"><span class="pre">L</span></tt>, the cholesky factor of <tt class="docutils literal"><span class="pre">A</span></tt>, in its lower triangle</td>
</tr>
<tr class="field-even field"><th class="field-name">size_m:</th><td class="field-body">number of rows of <tt class="docutils literal"><span class="pre">A,</span> <span class="pre">X,</span> <span class="pre">B</span></tt>; number of columns of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_n:</th><td class="field-body">number of columns of <tt class="docutils literal"><span class="pre">X,</span> <span class="pre">B</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">X[size_m][size_n]:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">matrix of RHS vectors, <tt class="docutils literal"><span class="pre">B`</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">X[size_m][size_n]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">matrix of solutions, <tt class="docutils literal"><span class="pre">A\B</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</p>
</div>
<div class="section" id="gpp-linear-algebra-cpp">
<h2>gpp_linear_algebra.cpp<a class="headerlink" href="#gpp-linear-algebra-cpp" title="Permalink to this headline">¶</a></h2>
<p></p>
<p><p>Implementations of functions for linear algebra operations; the functionality here largely is a subset of that
supported by BLAS and LAPACK.</p>
<p>Linear algebra functions currently do not call libraries like the BLAS/LAPACK because for [currently] small problem
sizes, overhead kills their performance advantage.  Additionally, for the custom implementations on our specific use
cases we also gain some performance through more restrictive assumptions on data ordering and no need (due to small
problem size) for advanced and complex optimizations like blocking.</p>
<p>However, if/when BLAS is needed, current linear algebra functions are designed to easily map into BLAS calls so they
can serve as wrappers later.  This also makes it easy to handle BLAS from different vendors and on different computing
environments (e.g., GPUs, Xeon Phi).</p>
<p>See gpp_linear_algebra.hpp file docs and (primarily) gpp_common.hpp for a few important implementation notes
(e.g., restrict, memory allocation, matrix storage style, etc).  Note the matrix looping idiom (gpp_common.hpp,
item 8) in particular; in summary, we use:</p>
<div class="highlight-python"><div class="highlight"><pre>for (int i = 0; i &lt; m; ++i) {
  y[i] = 0;
  for (int j = 0; j &lt; n; ++j) {
    y[i] += A[j]*x[j];
  }
  A += n;
}
</pre></div>
</div>
 </p>
<em>Defines</em><blockquote>
<div><p><span class="target" id="project0gpp__linear__algebra_8cpp_1a993b861bb802e2fceb1b58b996f23e72"></span><strong>OL_CHOL</strong>(i, j)</p>
<blockquote>
<div><p></p>
<p></p>
</div></blockquote>
</div></blockquote>
<p><p id="project0namespaceoptimal__learning"><em>namespace</em> <strong>optimal_learning</strong></p>
<blockquote>
<div><p></p>
<p></p>
<em>Functions</em><blockquote>
<div><p><span class="target" id="project0namespaceoptimal__learning_1a54d81ed0a0889142abeee4a0c255c2d1"></span><div class="line-block">
<div class="line">double <strong>VectorNorm</strong>(double const *restrict vector, int size)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Slow (compared to computing <tt class="docutils literal"><span class="pre">\sqrt(x_i*x_i)</span></tt>) but stable computation of <tt class="docutils literal"><span class="pre">\||vector\|_2</span></tt></p>
<p>Computing <tt class="docutils literal"><span class="pre">norm</span> <span class="pre">+=</span> <span class="pre">Square(vector[i])</span></tt> can be unsafe due to overflow &amp; precision loss.</p>
<p>Note that for very large vectors, this method is still potentially inaccurate.  BUT
we are not using anything nearly that large right now.
The best solution for accuracy would be to use Kahan summation.
Around 10^16 elements, this function will fail most of the time.  Around 10^8
elements, the loss of precision may already be substantial.</p>
</p>
<p><p>Computes <tt class="docutils literal"><span class="pre">\|x\|_2</span></tt> in a reasonably (see implementation notes) accurate and stable way.</p>
<p>Slower than the naive implementation due to scaling done to prevent overflow &amp; reduce precision loss.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">vector[size]:</th><td class="field-body">the vector x</td>
</tr>
<tr class="field-even field"><th class="field-name">size:</th><td class="field-body">number of elements in x</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Returns</strong>:</dt>
<dd>The vector 2-norm (aka Euclidean norm) of x.</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a6b98e93913d0d448b9f3dbd74ca4b77c"></span><div class="line-block">
<div class="line">void <strong>ComputeCholeskyFactorL</strong>(int size_m, double *restrict chol)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Cholesky factorization, <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">L^T</span></tt> (see Smith 1995 or Golub, Van Loan 1983, etc.)
This implementation uses the outer-product formulation.  The outer-product version is
2x slower than gaxpy or dot product style implementations; this is to remain consistent with
Smith 1995&#8217;s formulation of the gradient of cholesky.</p>
<p>This implemention is not optimized nor does it pivot when symmetric, indefinite matrices
or poorly conditioned SPD matrices are detected.</p>
<p>Instead, non-SPD matrices trigger an error printed to stdout.</p>
<p>Should be the same as BLAS call:
<tt class="docutils literal"><span class="pre">dpotrf('L',</span> <span class="pre">size_m,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">&amp;info);</span></tt>
Implementation is similar to <tt class="docutils literal"><span class="pre">dpotf2</span></tt>, the unblocked version (same arg list as <tt class="docutils literal"><span class="pre">dpotrf</span></tt>).</p>
</p>
<p><p>Computes the cholesky factorization of a symmetric, positive-definite (SPD) matrix,
<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">L^T</span></tt>; <tt class="docutils literal"><span class="pre">A</span></tt> is the input matrix, <tt class="docutils literal"><span class="pre">L</span></tt> is the (lower triangular) cholesky factor.
<tt class="docutils literal"><span class="pre">O(n^3)</span></tt> operations.
No inputs may be nullptr.</p>
<p>A must be SPD.  Calling this function on an indefinite matrix will produce a
nonsensical <tt class="docutils literal"><span class="pre">L.</span></tt>
Calling this function on a semi-definite matrix may result in a severe loss of precision
as well as inaccurate <tt class="docutils literal"><span class="pre">L</span></tt>.</p>
<p>The strict upper triangle of chol is NOT accessed.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">size_m:</th><td class="field-body">dimension of matrix</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">chol[size_m][size_m]:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">SPD (square) matrix (<tt class="docutils literal"><span class="pre">A</span></tt>) (on entry)</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">chol[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">cholesky factor of <tt class="docutils literal"><span class="pre">A</span></tt> (<tt class="docutils literal"><span class="pre">L</span></tt>).  <tt class="docutils literal"><span class="pre">L</span></tt> is stored in the lower triangle
of <tt class="docutils literal"><span class="pre">A</span></tt>.  Do not acccess the upper triangle of <tt class="docutils literal"><span class="pre">L</span></tt>. (on exit)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a4d552a03625982310d3ce5d90d252677"></span><div class="line-block">
<div class="line">void <strong>TriangularMatrixVectorSolve</strong>(double const *restrict A, char trans, int size_m, int lda, double *restrict x)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Solve <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt> or <tt class="docutils literal"><span class="pre">A^T*x</span> <span class="pre">=</span> <span class="pre">b</span></tt> when <tt class="docutils literal"><span class="pre">A</span></tt> is lower triangular IN-PLACE.
Uses the standard &#8220;backsolve&#8221; technique, instead of forming <tt class="docutils literal"><span class="pre">A^-1</span></tt> which is
VERY poorly conditioned.  Backsolve, however, is backward-stable.</p>
<p>See .h file docs for information on &#8220;lda&#8221;.</p>
<p>Should be equiv to BLAS call:
<tt class="docutils literal"><span class="pre">dtrsv('L',</span> <span class="pre">'N',</span> <span class="pre">'N',</span> <span class="pre">size_m,</span> <span class="pre">A,</span> <span class="pre">lda,</span> <span class="pre">x,</span> <span class="pre">1);</span></tt></p>
</p>
<p><p>Solves the system <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt> or <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt> when <tt class="docutils literal"><span class="pre">A</span></tt> is lower triangular. <tt class="docutils literal"><span class="pre">A</span></tt> must be nonsingular.
Before calling, <tt class="docutils literal"><span class="pre">x</span></tt> holds the RHS, <tt class="docutils literal"><span class="pre">b</span></tt>.  After return, <tt class="docutils literal"><span class="pre">x</span></tt> will be OVERWRITTEN with
the solution.
No inputs may be nullptr.</p>
<p>DOES NOT form <tt class="docutils literal"><span class="pre">A^-1</span></tt> explicitly.</p>
<p>Nonsensical output for singular <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">input to be solved; must be lower triangular and non-singular</td>
</tr>
<tr class="field-even field"><th class="field-name">trans:</th><td class="field-body">&#8216;N&#8217; to solve <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt>, &#8216;T&#8217; to solve <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_m:</th><td class="field-body">dimension of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">lda:</th><td class="field-body">the first dimension of <tt class="docutils literal"><span class="pre">A</span></tt> as declared by the caller; <tt class="docutils literal"><span class="pre">lda</span> <span class="pre">&gt;=</span> <span class="pre">size_m</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">x[size_m]:</th><td class="field-body">the RHS vector, <tt class="docutils literal"><span class="pre">b</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">x[size_m]:</th><td class="field-body">the solution, <tt class="docutils literal"><span class="pre">A\b</span></tt>.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a08478883e89679b7e82af904aba6079d"></span><div class="line-block">
<div class="line">void <strong>TriangularMatrixMatrixSolve</strong>(double const *restrict A, char trans, int size_m, int size_n, int lda, double *restrict X)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Calls dtrsv on each column of <tt class="docutils literal"><span class="pre">X</span></tt>, solving <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X_i</span> <span class="pre">=</span> <span class="pre">B_i</span></tt> (<tt class="docutils literal"><span class="pre">X_i</span></tt> being <tt class="docutils literal"><span class="pre">i</span></tt>-th column of <tt class="docutils literal"><span class="pre">X</span></tt>).
Does not use blocking or any other optimization techniques.</p>
<p>Should be equiv to BLAS call:
<tt class="docutils literal"><span class="pre">dtrsm('L',</span> <span class="pre">'L',</span> <span class="pre">'N',</span> <span class="pre">'N',</span> <span class="pre">size_m,</span> <span class="pre">size_n,</span> <span class="pre">1.0,</span> <span class="pre">A,</span> <span class="pre">lda,</span> <span class="pre">B,</span> <span class="pre">size_m);</span></tt></p>
</p>
<p><p>Solve <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></tt> or <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></tt> (<tt class="docutils literal"><span class="pre">A,</span> <span class="pre">X,</span> <span class="pre">B</span></tt> matrices) when <tt class="docutils literal"><span class="pre">A</span></tt> is lower triangular.
Solves IN-PLACE.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">input to be solved; must be lower triangular and non-singular</td>
</tr>
<tr class="field-even field"><th class="field-name">trans:</th><td class="field-body">&#8216;N&#8217; to solve <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></tt>, &#8216;T&#8217; to solve <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">B</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_m:</th><td class="field-body">dimension of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">lda:</th><td class="field-body">the first dimension of <tt class="docutils literal"><span class="pre">A</span></tt> as declared by the caller; <tt class="docutils literal"><span class="pre">lda</span> <span class="pre">&gt;=</span> <span class="pre">size_m</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">X[size_m]:</th><td class="field-body">the RHS matrix, <tt class="docutils literal"><span class="pre">B</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">X[size_m]:</th><td class="field-body">the solution, <tt class="docutils literal"><span class="pre">A\B</span></tt>.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ac131acb64f680fc9b87948b3b59d194d"></span><div class="line-block">
<div class="line">void <strong>TriangularMatrixInverse</strong>(double const *restrict matrix, int size_m, double *restrict inv_matrix)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Computes <tt class="docutils literal"><span class="pre">A^-1</span></tt>, the inverse of <tt class="docutils literal"><span class="pre">A</span></tt> when <tt class="docutils literal"><span class="pre">A</span></tt> has been previously cholesky-factored.
Only the lower triangle of <tt class="docutils literal"><span class="pre">A</span></tt> is read.</p>
<p>Computes inverse by successive <tt class="docutils literal"><span class="pre">x_i</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">\</span> <span class="pre">e_i</span></tt> operations, where <tt class="docutils literal"><span class="pre">e_i</span></tt> is the unit vector
with a 1 in the <tt class="docutils literal"><span class="pre">i</span></tt>-th entry.
Implementation saves computation (factor fo 2) by ignoring all leading zeros in <tt class="docutils literal"><span class="pre">x_i</span></tt>.  So <tt class="docutils literal"><span class="pre">x_0</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">\</span> <span class="pre">e_0</span></tt>
is <tt class="docutils literal"><span class="pre">\approx</span> <span class="pre">m^2</span></tt> operations, <tt class="docutils literal"><span class="pre">x_1</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">\</span> <span class="pre">e_1</span></tt> is <tt class="docutils literal"><span class="pre">\approx</span> <span class="pre">(m-1)^2</span></tt> operations, ..., and
<tt class="docutils literal"><span class="pre">x_{m-1}</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">\</span> <span class="pre">e_{m-1}</span></tt> is 1 operation.</p>
<p>This is NOT backward-stable and should NOT be used!  Substantial superfluous
numerical error can occur for poorly conditioned matrices.
Caveat: may have utility if you are very certain of what you are doing in the face of [severe] loss of precision</p>
</p>
<p><p>Computes <tt class="docutils literal"><span class="pre">L^-1</span></tt> when <tt class="docutils literal"><span class="pre">L</span></tt> is lower triangular.  <tt class="docutils literal"><span class="pre">L</span></tt> must be nonsingular otherwise
the output will be nonsense.</p>
<p>This is NOT backward-stable and should NOT be used!  Substantial superfluous
numerical error can occur for poorly conditioned matrices.
Caveat: may have utility if you are very certain of what you are doing in the face of [severe] loss of precision</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">matrix[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">triangular matrix, <tt class="docutils literal"><span class="pre">L</span></tt>, to be inverted</td>
</tr>
<tr class="field-even field"><th class="field-name">size_m:</th><td class="field-body">dimension of matrix</td>
</tr>
</tbody>
</table>
</dd>
<dt>OUPUTS:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">inv_matrix[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">inverse of <tt class="docutils literal"><span class="pre">L</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a54e8598e2c6628408138ed1fc93e2725"></span><div class="line-block">
<div class="line">void <strong>TriangularMatrixVectorMultiply</strong>(double const *restrict A, char trans, int size_m, double *restrict x)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Special case of GeneralMatrixVectorMultiply.  As long as A has zeros in the strict upper-triangle,
GeneralMatrixVectorMultiply will work too (but take <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">2x</span></tt> as long).</p>
<p>Computes results IN-PLACE.
Avoids accessing the strict upper triangle of A.</p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dtrmv('L',</span> <span class="pre">trans,</span> <span class="pre">'N',</span> <span class="pre">size_m,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">x,</span> <span class="pre">1);</span></tt></p>
</p>
<p><p>Computes <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span></tt> or <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span></tt> in-place.
<tt class="docutils literal"><span class="pre">A</span></tt> must be lower-triangular.  The vector <tt class="docutils literal"><span class="pre">x</span></tt> is OVERWRITTEN with the result before return.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">lower triangular matrix to be multiplied</td>
</tr>
<tr class="field-even field"><th class="field-name">trans:</th><td class="field-body">&#8216;N&#8217; for <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span></tt>, &#8216;T&#8217; for <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_m:</th><td class="field-body">dimension of <tt class="docutils literal"><span class="pre">A,</span> <span class="pre">x</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">x[size_m]:</th><td class="field-body">vector to multiply by <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">x[size_m]:</th><td class="field-body">the product <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span></tt> or <tt class="docutils literal"><span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ad014bdce18b859894f81f32286859a19"></span><div class="line-block">
<div class="line">void <strong>SymmetricMatrixVectorMultiply</strong>(double const *restrict A, double const *restrict x, int size_m, double *restrict y)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Special case of GeneralMatrixVectorMultiply for symmetric A (need not be SPD).
As long as A is stored fully (i.e., upper triangle is valid),
GeneralMatrixVectorMultiply will work too (but take <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">2x</span></tt> as long).</p>
<p>Avoids accessing the strict upper triangle of A.</p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dsymv('L',</span> <span class="pre">size_m,</span> <span class="pre">1.0,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">x,</span> <span class="pre">1,</span> <span class="pre">0.0,</span> <span class="pre">y,</span> <span class="pre">1);</span></tt></p>
</p>
<p><p>Computes <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span></tt> (or equivalently <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span></tt>).  This is NOT done in-place.
A must be symmetric.  Only the lower triangular part of A is read, so there is no need
to store the duplicate values when using this function.
No inputs may be nullptr.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">symmetric matrix to be multiplied</td>
</tr>
<tr class="field-even field"><th class="field-name">x[size_m]:</th><td class="field-body">vector to multiply by <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_m:</th><td class="field-body">dimension of <tt class="docutils literal"><span class="pre">A,</span> <span class="pre">x</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">y[size_m]:</th><td class="field-body">the product <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ab84a7924a1a85e7bad06494cd592347d"></span><div class="line-block">
<div class="line">void <strong>GeneralMatrixVectorMultiply</strong>(double const *restrict A, char trans, double const *restrict x, double alpha, double beta, int size_m, int size_n, int lda, double *restrict y)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Computes matrix-vector product <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">y</span></tt> or <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">y</span></tt>.
Since <tt class="docutils literal"><span class="pre">A</span></tt> is stored column-major, we treat the matrix-vector product as a weighted sum
of the columns of <tt class="docutils literal"><span class="pre">A</span></tt>, where <tt class="docutils literal"><span class="pre">x</span></tt> provides the weights.</p>
<p>That is, a matrix-vector product can be thought of as: (<tt class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">'T'</span></tt>)
<tt class="docutils literal"><span class="pre">[</span>&nbsp; <span class="pre">a_row1</span>&nbsp; <span class="pre">][</span>&nbsp;&nbsp; <span class="pre">]</span></tt>
<tt class="docutils literal"><span class="pre">[</span>&nbsp; <span class="pre">a_row2</span>&nbsp; <span class="pre">][</span> <span class="pre">x</span> <span class="pre">]</span></tt>
<tt class="docutils literal"><span class="pre">[</span>&nbsp;&nbsp;&nbsp; <span class="pre">...</span>&nbsp;&nbsp; <span class="pre">][</span>&nbsp;&nbsp; <span class="pre">]</span></tt>
<tt class="docutils literal"><span class="pre">[</span>&nbsp; <span class="pre">a_rowm</span>&nbsp; <span class="pre">][</span>&nbsp;&nbsp; <span class="pre">]</span></tt>
That is, <tt class="docutils literal"><span class="pre">y_i</span></tt> is the dot product of the <tt class="docutils literal"><span class="pre">i</span></tt>-th row of <tt class="docutils literal"><span class="pre">A</span></tt> with <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>OR the &#8220;dual&#8221; view: (<tt class="docutils literal"><span class="pre">trans</span> <span class="pre">=</span> <span class="pre">'N'</span></tt>)
<tt class="docutils literal"><span class="pre">[</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">|</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">|</span>&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">|</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">][</span> <span class="pre">x_1</span> <span class="pre">]</span></tt>
<tt class="docutils literal"><span class="pre">[</span> <span class="pre">a_col1</span> <span class="pre">|</span> <span class="pre">a_col2</span> <span class="pre">|</span> <span class="pre">...</span> <span class="pre">|</span> <span class="pre">a_coln</span> <span class="pre">][</span> <span class="pre">...</span> <span class="pre">]</span> <span class="pre">=</span> <span class="pre">x_1*a_col1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">x_n*a_coln</span></tt>
<tt class="docutils literal"><span class="pre">[</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">|</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">|</span>&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">|</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">][</span> <span class="pre">x_n</span> <span class="pre">]</span></tt>
That is, <tt class="docutils literal"><span class="pre">y</span></tt> is the weighted sum of columns of <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dgemv(trans,</span> <span class="pre">size_m,</span> <span class="pre">size_n,</span> <span class="pre">alpha,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">x,</span> <span class="pre">1,</span> <span class="pre">beta,</span> <span class="pre">y,</span> <span class="pre">1);</span></tt></p>
</p>
<p><p>Computes <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">y</span></tt> or <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">A^T</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">y</span></tt>.  This is NOT done in-place
A can be any 2 dimensional matrix (no requirements on triangularity, symmetry, etc)
No inputs may be nullptr.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_n]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">input matrix to be multiplied</td>
</tr>
<tr class="field-even field"><th class="field-name">trans:</th><td class="field-body">whether to multiply by <tt class="docutils literal"><span class="pre">A</span></tt> (&#8216;N&#8217;) or <tt class="docutils literal"><span class="pre">A^T</span></tt> (&#8216;T&#8217;)</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">x[size_n OR size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">vector to multiply by <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">size_n</span></tt> if <tt class="docutils literal"><span class="pre">trans=='N'</span></tt>, <tt class="docutils literal"><span class="pre">size_m</span></tt> if <tt class="docutils literal"><span class="pre">trans=='T'</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">alpha:</th><td class="field-body">scale factor on <tt class="docutils literal"><span class="pre">A*x</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">beta:</th><td class="field-body">scale factor on <tt class="docutils literal"><span class="pre">y</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">size_m:</th><td class="field-body">number of rows of <tt class="docutils literal"><span class="pre">A</span></tt>; size of <tt class="docutils literal"><span class="pre">y</span></tt> if <tt class="docutils literal"><span class="pre">trans</span> <span class="pre">==</span> <span class="pre">'N'</span></tt>, size of <tt class="docutils literal"><span class="pre">x</span></tt> if <tt class="docutils literal"><span class="pre">trans</span> <span class="pre">==</span> <span class="pre">'T'</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_n:</th><td class="field-body">number of columns of <tt class="docutils literal"><span class="pre">A</span></tt>, size of <tt class="docutils literal"><span class="pre">x</span></tt> if <tt class="docutils literal"><span class="pre">trans</span> <span class="pre">==</span> <span class="pre">'N'</span></tt>, size of <tt class="docutils literal"><span class="pre">y</span></tt> if <tt class="docutils literal"><span class="pre">trans</span> <span class="pre">==</span> <span class="pre">'T'</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">lda:</th><td class="field-body">the first dimension of <tt class="docutils literal"><span class="pre">A</span></tt> as declared by the caller; <tt class="docutils literal"><span class="pre">lda</span> <span class="pre">&gt;=</span> <span class="pre">size_m</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">y[size_m OR size_n]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">the product <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">x</span></tt> (<tt class="docutils literal"><span class="pre">size_m</span></tt> if <tt class="docutils literal"><span class="pre">trans=='N'</span></tt>, <tt class="docutils literal"><span class="pre">size_n</span></tt> if <tt class="docutils literal"><span class="pre">trans</span> <span class="pre">==</span> <span class="pre">'T'</span></tt>)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ac7aa9084e57952829331e87c37e7eb5f"></span><div class="line-block">
<div class="line">void <strong>GeneralMatrixMatrixMultiply</strong>(double const *restrict Amat, char transA, double const *restrict Bmat, double alpha, double beta, int size_m, int size_k, int size_n, double *restrict Cmat)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Matrix-matrix product <tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">op(A)</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">C</span></tt>, where <tt class="docutils literal"><span class="pre">op(A)</span></tt> is <tt class="docutils literal"><span class="pre">A</span></tt> or <tt class="docutils literal"><span class="pre">A^T</span></tt>.
Does so by computing matrix-vector products of <tt class="docutils literal"><span class="pre">A</span></tt> with each column of <tt class="docutils literal"><span class="pre">B</span></tt>
(to generate corresponding column of <tt class="docutils literal"><span class="pre">C</span></tt>).</p>
<p>Does not use blocking or other advanced optimization techniques.</p>
<p>Should be equivalent to BLAS call:
<tt class="docutils literal"><span class="pre">dgemm('N',</span> <span class="pre">'N',</span> <span class="pre">size_m,</span> <span class="pre">size_n,</span> <span class="pre">size_k,</span> <span class="pre">alpha,</span> <span class="pre">A,</span> <span class="pre">size_m,</span> <span class="pre">B,</span> <span class="pre">size_k,</span> <span class="pre">beta,</span> <span class="pre">C,</span> <span class="pre">size_m);</span></tt></p>
</p>
<p><p>Computes the matrix-matrix product <tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">op(A)</span> <span class="pre">*</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">C</span></tt>, where <tt class="docutils literal"><span class="pre">op(A)</span> <span class="pre">=</span> <span class="pre">A</span></tt> or <tt class="docutils literal"><span class="pre">A^T</span></tt>, depending on transA
<tt class="docutils literal"><span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C</span></tt> can be general matrices (no requirements on symmetry, etc.)
Equivalent to calling GeneralMatrixVectorMultiply with <tt class="docutils literal"><span class="pre">A</span></tt> against each column of <tt class="docutils literal"><span class="pre">B</span></tt>.
No inputs may be nullptr.</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">A[size_m][size_k]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">left matrix multiplicand</td>
</tr>
<tr class="field-even field"><th class="field-name">transA:</th><td class="field-body">whether to multiply by <tt class="docutils literal"><span class="pre">A</span></tt> (&#8216;N&#8217;) or <tt class="docutils literal"><span class="pre">A^T</span></tt> (&#8216;T&#8217;)</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">B[size_k][size_n]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">right matrix multiplicand</td>
</tr>
<tr class="field-even field"><th class="field-name">alpha:</th><td class="field-body">scale factor on <tt class="docutils literal"><span class="pre">A*B</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">beta:</th><td class="field-body">scale factor on <tt class="docutils literal"><span class="pre">C</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">size_m:</th><td class="field-body">rows of <tt class="docutils literal"><span class="pre">op(A),</span> <span class="pre">C</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">size_k:</th><td class="field-body">cols of <tt class="docutils literal"><span class="pre">op(A)</span></tt>, rows of <tt class="docutils literal"><span class="pre">B</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">size_n:</th><td class="field-body">cols of <tt class="docutils literal"><span class="pre">B,</span> <span class="pre">C</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">C[size_m][size_n]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">the result <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></tt></td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a71d22dd78feea3f809a928927017acf3"></span><div class="line-block">
<div class="line">void <strong>MatrixTranspose</strong>(double const *restrict matrix, int num_rows, int num_cols, double *restrict transpose)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Transposes a 2D matrix. <tt class="docutils literal"><span class="pre">O(num_rows*num_cols)</span> <span class="pre">=</span> <span class="pre">O(n^2)</span></tt> for square matrices
Would have no effect on symmetric matrices.</p>
<p>For example, <tt class="docutils literal"><span class="pre">A[3][4]</span> <span class="pre">=</span> <span class="pre">[4</span> <span class="pre">53</span> <span class="pre">81</span> <span class="pre">32</span> <span class="pre">12</span> <span class="pre">2</span> <span class="pre">5</span> <span class="pre">8</span> <span class="pre">93</span> <span class="pre">2</span> <span class="pre">1</span> <span class="pre">0]</span></tt>
becomes      <tt class="docutils literal"><span class="pre">A[4][3]</span> <span class="pre">=</span> <span class="pre">[4</span> <span class="pre">32</span> <span class="pre">5</span> <span class="pre">2</span> <span class="pre">53</span> <span class="pre">12</span> <span class="pre">8</span> <span class="pre">1</span> <span class="pre">81</span> <span class="pre">2</span> <span class="pre">93</span> <span class="pre">0]</span></tt></p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">matrix[num_rows][num_cols]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">matrix to be transposed</td>
</tr>
<tr class="field-even field"><th class="field-name">num_rows:</th><td class="field-body">number of rows in matrix</td>
</tr>
<tr class="field-odd field"><th class="field-name">num_cols:</th><td class="field-body">number of columns in matrix</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">transpose[num_cols][num_rows]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">transpose of matrix</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1ac90ed324d76a0a9a643ccb78580908cd"></span><div class="line-block">
<div class="line">void <strong>SPDMatrixInverse</strong>(double const *restrict chol_matrix matrix, int size_m, double *restrict inv_matrix)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Computes <tt class="docutils literal"><span class="pre">A^-1</span></tt> by cholesky-factoring <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">L^T</span></tt>, computing <tt class="docutils literal"><span class="pre">L^-1</span></tt>, and then
computing <tt class="docutils literal"><span class="pre">A^-1</span> <span class="pre">=</span> <span class="pre">L^-T</span> <span class="pre">*</span> <span class="pre">L^-1</span></tt>.</p>
<p>This is NOT backward-stable and should NOT be used!  Substantial superfluous
numerical error can occur for poorly conditioned matrices.
Caveat: may have utility if you are very certain of what you are doing in the face of [severe] loss of precision</p>
</p>
<p><p>Computes <tt class="docutils literal"><span class="pre">A^-1</span></tt> when <tt class="docutils literal"><span class="pre">A</span></tt> is SPD.  Output is nonsense for non-SPD A matrices.
A must be previously cholesky-factored (e.g., via ComputeCholeskyFactorL)</p>
<p>This is NOT backward-stable and should NOT be used!  Substantial superfluous
numerical error can occur for poorly conditioned matrices.
Caveat: may have utility if you are very certain of what you are doing in the face of [severe] loss of precision</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">matrix[size_m][size_m]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">matrix, <tt class="docutils literal"><span class="pre">A</span></tt>, to be inverted (only the lower-triangle is read)
<tt class="docutils literal"><span class="pre">A</span></tt> must be previously cholesky-factored.</td>
</tr>
<tr class="field-even field"><th class="field-name">size_m:</th><td class="field-body">dimension of <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">inv_matrix:</th><td class="field-body"><tt class="docutils literal"><span class="pre">A^-1</span></tt> (stored as a full matrix even though it is symmetric)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a82e44454c243941944b078a0a4df556e"></span><div class="line-block">
<div class="line">int <strong>ComputePLUFactorization</strong>(int r, int *restrict pivot, double *restrict A)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p>Computes the PLU factorization of a matrix A using LU-decomposition with partial pivoting: <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">P</span> <span class="pre">*</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">U</span></tt>.
<tt class="docutils literal"><span class="pre">P</span></tt> is a permutation matrix&#8211;an identity matrix with some rows (potentially) swapped.
<tt class="docutils literal"><span class="pre">L</span></tt> is lower triangular with 1s on the diagonal.
<tt class="docutils literal"><span class="pre">U</span></tt> is upper triangular.
Since <tt class="docutils literal"><span class="pre">L</span></tt>&#8216;s diagonal is unit, <tt class="docutils literal"><span class="pre">L</span></tt> and <tt class="docutils literal"><span class="pre">U</span></tt> can be stored together in <tt class="docutils literal"><span class="pre">A</span></tt> (omitting the 1s).
Since <tt class="docutils literal"><span class="pre">P</span></tt> is just a permuted identity, we can instead track the row-swaps done in a vector.</p>
<p>Fails with error code if the matrix is definitely singular&#8211;a pivot element is 0 or subnormal.</p>
<p>For further details:
1. <a class="reference external" href="http://en.wikipedia.org/wiki/LU_decomposition">http://en.wikipedia.org/wiki/LU_decomposition</a> (not the best info really)
2. L. Trefethen and D. Bau, Numerical Linear Algebra, Chp 20-23
3. G. Golub and C. Van Loan, Matrix Computations, Chp 3.
4. keywords: PLU, LU factorization/decomposition [with partial pivoting]</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">r:</th><td class="field-body">dimension of the matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">A[size][size]:</th><td class="field-body">the matrix to be factored (e.g., describing a system of equations)</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">pivot[size]:</th><td class="field-body">array of pivot positions (i.e., row-swaps) used during factorization</td>
</tr>
<tr class="field-even field"><th class="field-name">A[size][size]:</th><td class="field-body">a matrix containing the <tt class="docutils literal"><span class="pre">L,</span> <span class="pre">U</span></tt> factors</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Returns</strong>:</dt>
<dd>0 if successful.  Otherwise the index (fortran-style, from 1) of the failed pivot element.</dd>
</dl>
 </p>
</div></blockquote>
<p><span class="target" id="project0namespaceoptimal__learning_1a4e3a8d0c08e4dab85d5f8bbcb820961e"></span><div class="line-block">
<div class="line">void <strong>PLUMatrixVectorSolve</strong>(int r, double const *restrict LU, int const *restrict pivot, double *restrict b)</div>
</div>
</p>
<blockquote>
<div><p></p>
<p><p><p>Solves the system <tt class="docutils literal"><span class="pre">P</span> <span class="pre">*</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt>.</p>
<ol class="arabic simple">
<li>Apply the permutation <tt class="docutils literal"><span class="pre">P</span></tt> (pivot) to <tt class="docutils literal"><span class="pre">b</span></tt>.</li>
<li>Forward-substitute to solve <tt class="docutils literal"><span class="pre">Ly</span> <span class="pre">=</span> <span class="pre">Pb</span></tt>.  This loop is unrolled 4 times for speed.</li>
<li>Backward-substitute to solve <tt class="docutils literal"><span class="pre">Ux</span> <span class="pre">=</span> <span class="pre">y</span></tt>.  This loop is also unrolled 4 times.</li>
</ol>
</p>
<p><p>Solves the system of equations <tt class="docutils literal"><span class="pre">A*x</span> <span class="pre">=</span> <span class="pre">b</span></tt>, where <tt class="docutils literal"><span class="pre">A</span></tt> has been previously PLU-factored (by ComputePLUFactorization()).
So in essence, solves: <tt class="docutils literal"><span class="pre">P</span> <span class="pre">*</span> <span class="pre">L</span> <span class="pre">*</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">b</span></tt>.
The input <tt class="docutils literal"><span class="pre">b</span></tt> is overwritten with the solution <tt class="docutils literal"><span class="pre">x</span></tt>.
<tt class="docutils literal"><span class="pre">A</span></tt> is provided in the matrix LU and the array pivot.  <tt class="docutils literal"><span class="pre">pivot</span></tt> represents the permutation matrix <tt class="docutils literal"><span class="pre">P</span></tt>.
The triangular matrices <tt class="docutils literal"><span class="pre">L</span></tt> and <tt class="docutils literal"><span class="pre">U</span></tt> are stored in <tt class="docutils literal"><span class="pre">A</span></tt>: the upper triangle of <tt class="docutils literal"><span class="pre">A</span></tt> holds <tt class="docutils literal"><span class="pre">U</span></tt>.
The strict lower triangle of <tt class="docutils literal"><span class="pre">A</span></tt> holds <tt class="docutils literal"><span class="pre">L</span></tt> (since <tt class="docutils literal"><span class="pre">L</span></tt>&#8216;s diagonal is unit).</p>
<dl class="docutils">
<dt><strong>Parameters</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">r:</th><td class="field-body">size of vector, dimension of matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">LU[size][size]:</th><td class="field-body">factored matrix containing <tt class="docutils literal"><span class="pre">L,</span> <span class="pre">U</span></tt> factors the original system, <tt class="docutils literal"><span class="pre">A</span></tt></td>
</tr>
<tr class="field-odd field"><th class="field-name">pivot[size]:</th><td class="field-body">pivot position array generated during LU decomposition with partial pivoting</td>
</tr>
<tr class="field-even field"><th class="field-name">b[size]:</th><td class="field-body">the right hand side</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>Outputs</strong>:</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">b[size]:</th><td class="field-body">the solution vector</td>
</tr>
</tbody>
</table>
</dd>
</dl>
 </p>
</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gpp_heuristic_expected_improvement_optimization_test.html" class="btn btn-neutral float-right" title="gpp_heuristic_expected_improvement_optimization_test"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gpp_geometry_test.html" class="btn btn-neutral" title="gpp_geometry_test"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Yelp and Cornell Collaboration.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>